렌더씬 구현

1. 멀티 스레드 렌더 씬 구현을 위해 3중 버퍼링 사용
2. 실제 유휴 프레임 수는 렌더링 속도에 따라 가변적으로 적용
3. 고속 복사를 위해 포인터 미사용 / 해당 버퍼에 업데이트 끝나고 렌더링 제출 전에 다음 프레임 렌더씬에 Memcopy
4. 각 프레임은 펜스로 관리 / 거의 없긴 하겠지만 uint64 벗어 날 경우 대비

기본적으로 화면에 띄우는 버퍼와 실제 사용자 조작 입력하는 버퍼는 1~3 프레임 차이
애니메이션 본 트랜스폼 계산 스레드 분리필요하면 분리
다만 본 트랜스폼 따라서 위치 반환이 필요한 경우가 잇을 수 있으니 이는 언리얼에서 어케 처리하는지 알아보기

아래와 같이 관리
1. 렌더링 + 이전 트랜스폼 버퍼
 - 읽기 전용
 - 렌더링하면서 읽고, 필요할 경우 업데이트에서 이전 프레임에서의 변경점 참조 용으로 읽기
 - 프레임 인덱스로 세마포어 하면 읽기 전용 보장 가능
 - 렌더링 완료하는건 펜스로 처리
2. Update
 - 실제 업데이트 수행 및 업데이트 결과 참조
 - 업데이트 수행한 결과는 여기 버퍼에 적용 한 뒤 업데이트가 끝날 경우 다음 프레임 버퍼에 덮어 씌우고 렌더링 역할로 전환
3. Buffer
 - 유휴 프레임

렌더씬에 필요한 정보

월드
    1. 렌더링 파라미터
    2. 후처리 정보

오브젝트별 
    1. WorldTransform 행렬 (TRS)
    2. 애니메이션 정보
    3. 최종 AABB (프러스텀 컬링에 필요한 최대크기, 최소크기) (애니메이션 적용된 경우)
메쉬 별
    1. 최종 AABB (프러스텀 컬링에 필요한 최대크기, 최소크기) (애니메이션 필요 없는 경우)
쉐이더 별
    1. 텍스처 쉐이더, 쉐이더 변수 등등의 메테리얼 정보

고려점
    1. 프러스텀 컬링 적용 스레드 누구?
        1-1 렌더스레드
        1-2 업데이트 스레드
        -> 이거는 프로파일링 해보고 정하기
        -> CPU, GPU 차이에 따라 디바이스별로 다를 가능성 있으니, 유동적으로도??
    2. 물리 연산은 Update 전에 
        -> 피직스 비동기 연산 적용
